---
layout:     post
title:      C++面经总结
subtitle:   基础内容
date:       2019-11-11
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - C++
---

## static关键字的作用
**1. 全局静态变量**
   + 形式：在全局变量前加上关键字static（此时全局变量就定义成一个全局静态变量）。
   + 位置：静态存储区（在整个程序运行期间一直存在）。
   + 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。
   + 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。（不会与其他cpp中的同名的全局变量冲突）
   
**2. 局部静态变量**
   + 形式：在局部变量之前加上关键字static（局部变量就成为一个局部静态变量）。
   + 位置 ：静态存储区
   + 初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。
   + 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，**并没有销毁**，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。
   
**3. 静态函数**
   + 在函数**返回类型**前加static，函数就定义为静态函数。(函数的定义和声明在默认情况下都是extern的，**但静态函数只是在声明他的文件当中可见，不能被其他文件所用**。)
   + **函数的实现**使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；
   + warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，**如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰**。
   
**4. 类的静态成员**
  + 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用**
   
**5. 类的静态函数**
  + 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，**对静态成员的引用不需要用对象名。**
  + 在静态成员函数的实现中**不能直接引用类中说明的非静态成员**，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);
  
**总结**
   1. 对于全局的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。
   2. 对于局部变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。
   3. 对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用。
   4. 对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。
   
## C++和C的区别

   **设计思想上：**
   C++是面向对象的语言，而C是面向过程的结构化编程语言。
   
   **语法上：**
     1. C++具有封装、继承和多态三种特性。
     2. C++相比C，增加多许多类型安全的功能，比如强制类型转换。
     3. C++支持范式编程，比如模板类、函数模板等。
      
## C++中四种cast转换

   1. const_cast：用于将const变量转为非const。
   2. static_cast:完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。
   3. dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。
   向下转化时，对于指针，转换失败则返回nullpt;对于引用，转换失败会抛出异常。要深入了解内部转换的原理。
   向上转换：指的是子类向基类的转换，向下转换：指的是基类向子类的转换。   
   它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
   4. reinterpret_cast:可以用于任意类型的指针之间的转换，比如将int转指针，可能会出问题，尽量少用；
   5. 为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。
   
## C/C++ 中指针和引用的区别

**定义：**
   1. 引用：C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。
   引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。
   2. 指针：指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。
   
**区别：**
   1. 空间：指针有自己的一块空间，而引用只是一个别名。
   2. 大小：使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。
   3. 初始化：指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用。
   4. 传递：作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。
   5. const修饰：可以有const指针，但是没有const引用。
   6. 更改：指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变。
   7. 多级：指针可以有多级指针（**p），而引用只有一级。
   8. 运算符：指针和引用使用++运算符的意义不一样。
   9. 动态内存：如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。
   
## C++智能指针

**为什么要使用智能指针**：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。
使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。
所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
C++里面smart pointer的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。

1. auto_ptr（c++98的方案，cpp11已经抛弃）
    采用所有权模式。
    ```
      auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
      auto_ptr<string> p2;
      p2 = p1; //auto_ptr不会报错.
    ```
    此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！
    
2. unique_ptr（替换auto_ptr）

unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。
采用所有权模式，还是上面那个例子
```
  unique_ptr<string> p3 (new string ("auto"));   //#4
  unique_ptr<string> p4；                       //#5
  p4 = p3;//此时会报错！！
```
编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。
另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：
```
  unique_ptr<string> pu1(new string ("hello world"));
  unique_ptr<string> pu2;
  pu2 = pu1;                                      // #1 not allowed
  unique_ptr<string> pu3;
  pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```
其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：
```
  unique_ptr<string> ps1, ps2;
  ps1 = demo("hello");
  ps2 = move(ps1);
  ps1 = demo("alexia");
  cout << *ps2 << *ps1 << endl;
```

3. shared_ptr

shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。
可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
成员函数：
use_count 返回引用计数的个数
unique 返回是否是独占所有权( use_count 为 1)
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

4. weak_ptr

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。
weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。
weak_ptr 是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。
它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。
```
  class B;
  class A
  {
  public:
  shared_ptr<B> pb_;
  ~A()
  {
  cout<<"A delete\n";
  }
  };
  class B
  {
  public:
  shared_ptr<A> pa_;
  ~B()
  {
  cout<<"B delete\n";
  }
  };
  void fun()
  {
  shared_ptr<B> pb(new B());
  shared_ptr<A> pa(new A());
  pb->pa_ = pa;
  pa->pb_ = pb;
  cout<<pb.use_count()<<endl;
  cout<<pa.use_count()<<endl;
  }
  int main()
  {
  fun();
  return 0;
  }
```
可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。
注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

## 智能指针的内存泄漏如何解决

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。


## 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

## C++中析构函数的作用

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。
析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。

## 请你来说一下静态函数和虚函数的区别

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

## 请你来说一说重载和重写
 
重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

## C字符串——库函数系列（strlen、strcat、strcpy、strcmp）

```
    strlen(s) : 返回S的长度，不包括字符串结束符NULL；
    strcmp(s1,s2) :比较两个字符串是否相同，若s1==s2，返回0，若s1>s2则返回正数，若s1<s2则返回负数；
    strcat(s1,s2)：将字符串s2连接到s1上，返回 s1；
    strcpy(s1,s2)：将s2，复制到s1，返回 s1.
```
## 虚函数和多态

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

##  以下四行代码的区别是什么？ const char * arr = "123"; char * brr = "123"; const char crr[] = "123"; char drr[] = "123";

`const char * arr = "123";`
字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样

`char * brr = "123";`
字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值

`const char crr[] = "123";`
这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区

`char drr[] = "123";`
字符串123保存在栈区，可以通过drr去修改

 ## C++里是怎么定义常量的？常量存放在内存的哪个位置？
 
 对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。
 
## 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？

不会，这相当于函数的重载。

## 隐式类型转换

首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。

## C++函数栈空间的最大值

默认是1M，不过可以调整

## extern“C”

C++调用C函数需要extern C，因为C语言没有函数重载。

## new/delete与malloc/free的区别

首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数,而前者会调用。

## RTTI

运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info

## 虚函数表具体是怎样实现运行时多态的

子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。

## C语言是怎么进行函数调用

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。

## C语言参数压栈顺序

从右到左

## C++如何处理返回值

生成一个临时变量，把它的引用作为函数参数传入函数内。

## C++中拷贝赋值函数的形参能否进行值传递

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。

## select

select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大

## fork,wait,exec函数

父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1




