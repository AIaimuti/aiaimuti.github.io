---
layout:     post
title:      C++容器
subtitle:   基础内容
date:       2019-11-11
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - C++
---

## map和set有什么区别，分别又是怎么实现的

map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。
map和set区别在于：
  1. map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
  2. **set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。** 其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。
  3. **map支持下标操作，set不支持下标操作。** map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。
  
## STL的allocaotr

STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：
  + new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容
  + delete运算分两个阶段：(1)调用对象析构函数；(2)掉员工::operator delete释放内存
为了精密分工，STL allocator将两个阶段操作区分开来：
  + 内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；
  + 对象构造由::construct()负责，对象析构由::destroy()负责。
同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器：
  + 第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，当分配的空间大小超过128B时，会使用第一级空间配置器。
  + 第二级空间配置器采用了内存池技术，通过空闲链表来管理内存，当分配的空间大小小于128B时，将使用第二级空间配置器。

## STL迭代器删除元素

这个主要考察的是迭代器失效的问题。
1. 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；
2. 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

## STL中MAP数据存放形式

红黑树。unordered map底层结构是哈希表

## STL基本组成

STL主要由：以下几部分组成：
容器、迭代器、仿函数、算法、分配器、配接器
他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

## STL中map与Multimap

1. Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。**不允许键值重复。**
底层实现：红黑树

适用场景：有序键值对不重复映射

2. Multimap

多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。**允许键值重复。**

底层实现：红黑树

适用场景：有序键值对可重复映射

## vector和list的区别及应用

概念：

1. Vector
    + 连续存储的容器，动态数组，在堆上分配空间
    + 底层实现：数组
    + 两倍容量增长：vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。
      如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空           间，之前的迭代器会失效。
    + 性能：访问：O(1)
    + 插入：在最后插入（空间够）：很快
      在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
      在中间插入（空间够）：内存拷贝
      在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
    + 删除：在最后删除：很快
      在中间删除：内存拷贝
    + 适用场景：经常随机访问，且不经常对非尾节点进行插入删除。

2、List

动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。

底层：双向链表

性能：

访问：随机访问性能很差，只能快速访问头尾节点。

插入：很快，一般是常数开销

删除：很快，一般是常数开销

适用场景：经常插入删除大量数据

2、区别：

1）vector底层实现是数组；list是双向 链表。

2）vector支持随机访问，list不支持。

3）vector是顺序内存，list不是。

4）vector在中间节点进行插入删除会导致内存拷贝，list不会。

5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。

6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

3、应用

vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。

list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。
