---
layout:     post
title:      链表
subtitle:   相关知识及题目
date:       2019-11-20
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - 链表
---


## 面试时链表解题的方法论
1. 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度
2. 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法

## 链表相关题目主要就是两个思路

1. 使用辅助空间，数组，哈希表等

2. 使用快慢指针。

## 哈希表简单介绍

1. 哈希表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderedSet)
3. 如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)
4. 有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事
5. 使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为O(1)，但是常数时间比较大
6. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
7. 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小.

## 有序表简单介绍

1. 有序表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)
3. 如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)
4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5. 有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
6. 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
7. 放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
8. 放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小
9. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度（O(N * logN)）

## 有序表的固定操作

1. voidput(Kkey,Vvalue)：将一个（key，value）记录加入到表中，或者将key的记录更新成value。
2. Vget(Kkey)：根据给定的key，查询value并返回。
3. voidremove(Kkey)：移除key的记录。
4. booleancontainsKey(Kkey)：询问是否有关于key的记录。
5. KfirstKey()：返回所有键值的排序结果中，最左（最小）的那个。
6. KlastKey()：返回所有键值的排序结果中，最右（最大）的那个。
7. KfloorKey(Kkey)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的前一个。
8. KceilingKey(Kkey)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的后一个。

以上所有操作时间复杂度都是O(logN)，N为有序表含有的记录数

## 题目整理

1. 反转单向和双向链表

迭代方法时间复杂度为O（n）,空间复杂度O（1），递归方法时间复杂度为O（n）,空间复杂度O（n）不做整理了 

**反转单向链表**

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
//等号都是拷贝链表本身，cur->next 这类带next的是链表的连接
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* new_head = NULL;
        while (cur){
            ListNode* temp = cur->next;  
            cur->next = new_head;        
            new_head = cur;              
            cur = temp;
        }
        return new_head;
    }
};
```

**反转双向链表**

```
/*
struct ListNode{
    ListNode* pre;
    int val;
    ListNode* next;
};*/

class Solution {
public:
    ListNode* reverseList(ListNode* head){
        ListNode* cur = head, *p_pre = NULL;   
        while (cur){                           
            ListNode* p_next = cur->next;   //首先令p_next指向cur->next;
            cur->next = p_pre;              //cur->next的断开，指向cur->pre
            cur->pre = p_next;              //cur->pre的断开，连接p_next，完成当前结点的前后指针反转
            p_pre = cur;                    //反转完成，后移p_pre指针。
            cur= p_next;                    //后移cur指针。
        }
        return p_pre;    //当cur为Null时，说明已经反转完毕，它的前一节点pre指向尾节点。返回此节点指针。
    }
};
```

2. 打印两个有序链表的公共部分

不相等的部分小者向后移动，相等的部分打印

```
void sol(list_node * a_head, list_node * b_head)
{
    //////在下面完成代码
    while (a_head && b_head){
        if(a_head->val < b_head->val){
            a_head = a_head->next;
        }
        else if (a_head->val > b_head->val){
            b_head = b_head->next;
        }
        else if (a_head->val  == b_head->val ){
            cout << a_head->val << " ";
            a_head = a_head->next;
            b_head = b_head->next;
        }
    }
}
```

3. 判断一个链表是否为回文结构

**使用栈**，将链表元素放入栈内，如果遇见相同的就弹出，最后栈为空则为回文结构，O（n）,空间复杂度O（n）

**代码**

```
using namespace std;
class PalindromeList {
public:
    bool chkPalindrome(ListNode* A) {
        stack <int> s;
        while (A){
        if (s.empty() || A->val != s.top()){
            s.push(A->val);
            A = A->next;
        }
        else {
            s.pop();
            A = A->next;
        }
        }
        return s.empty();
    }
};
```
+ 使用快慢指针原地修改链表,额外空间复杂度O（1）

```
using namespace std;
class PalindromeList {
public:
    bool chkPalindrome(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return true;
        }
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != NULL && fast->next->next != NULL) {
            fast = fast->next->next;
            slow = slow->next;
        }
        slow = reverseList(slow->next);
        while (slow != NULL) {
            if (head->val != slow->val) {
                return false;
            }
            head = head->next;
            slow = slow->next;
        }
        return true;
    }
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL;
        ListNode* here = head;
        while (here!=NULL) {
            ListNode* temp = here->next;
            here->next = pre;
            pre = here;
            here = temp;
        }
        return pre;
    }
};
```



