---
layout:     post
title:      动态规划
subtitle:   基础内容
date:       2020-3-10
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - 数据结构及算法
---

## 动态规划问题概述

动态规划问题的一般形式就是求最值，求最值最直观的方法是穷举，动态规划核心问题是穷举，然后在其中找最值。动态规划问题有三个要素：

1.**重叠子问题**

动态规划需要解决的原问题往往存在「重叠子问题」，即原问题暴力穷举时会重复计算子问题，这些重复计算会大幅降低运算效率，其「重叠子问题」可以通过「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

2.**最优子结构**

动态规划问题是将原问题拆分为子问题进行求解，其子问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。

3.**状态转移方程**

状态转移方程在于如何将原问题拆分为子问题进行求解，即根据 dp(i)和 dp(i-1) 的关系得出状态转移方程，只有列出正确的「状态转移方程」才能正确地穷举。

**动态规划的一般解题步骤为：**


1.确定「状态」，明确原问题和子问题中变化的变量；
2.定义 dp 数组/函数，明确 dp(i)应该表示什么（二维情况：dp(i)(j)）；
3.确定初始条件，如 dp(0)dp(0)。
4.根据 dp(i)和 dp(i-1)的关系得出状态转移方程；

## 典型例子

**凑零钱问题（Leetcode 322）**

先看下题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

`int coinChange(int[] coins, int amount);`

比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。

1. 暴力递归

首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。

比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。

那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？

**先确定「状态」，也就是原问题和子问题中变化的变量。**由于硬币数量无限，所以唯一的状态就是目标金额 amount。

**然后确定 dp 函数的定义：**当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。

**然后确定「选择」并择优，**也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少：

```
def coinChange(coins: List[int], amount: int):
    # 定义：要凑出金额 n，至少要 dp(n) 个硬币
    def dp(n):
        # 初始条件
        if n == 0: return 0
        if n < 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        # 状态转移，做选择，选择需要硬币最少的那个结果
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)
        return res if res != float('INF') else -1
    # 我们要求的问题是 dp(amount)
    return dp(amount)
```
以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：

$$
f(n)
\begin{cases}
0, n = 0 \\
-1, n < 0 \\
min(dp(n - coins) + 1| coin \in coins), n > 0 \\
\end{cases}
$$



本文参考内容
https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/gu-piao-wen-ti-python3-c-by-z1m/
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/


