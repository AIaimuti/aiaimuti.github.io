---
layout:     post
title:      Fps 武器连发和基础武器摇动
subtitle:   基础内容
date:       2020-4-16
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - UE4 蓝图实现FPS系列
---

## 基础武器晃动

采用F插值到Finterp To函数
第一个Current参数为当前值
第二个target参数：目标值
第三个参数delta Time:两帧之间的时间
第四个参数Interp Speed:插值速度
功能就是将Current值按一定速度不断增加到target值，起到平滑的作用。
类似的还有Vinterp To、Rinterp To和Tinterp To

**功能需求**：FPS在游戏中实现简单的晃动效果就是获取鼠标X、Y轴的偏移量，在此基础上进行一个偏移量的插值作用于骨骼，形成晃动的效果

首先，**在Player蓝图**中将鼠标X、Y轴的输入量获取为变量Shake_X_Axis和Shake_Y_Axis。
然后在**动画蓝图**中蓝图动画初始化的时候 CastToPlayer，获取Player相关参数，即Shake_X_Axis和Shake_Y_Axis，这个值一种在变，所以作为target参数。
然后新建Y Bias和 Z Bias作为初始变量，采用Finterp To函数，将输出的值分别赋给Y Bias和 Z Bias
Y Bias为竖直方向骨骼晃动，Transform(modify)Bone X引脚竖直控制骨骼晃动，Y Bias连接X引脚；
Z Bias为水平方向骨骼晃动，Transform(modify)Bone Z引脚水平控制骨骼晃动，Z Bias连接Z引脚；


GetAllActorsOfClass性能开销会比较大
一般物体创建的时候进行CastTo操作进行变量的生成会性能好一些

## 射线检测

Object Channel：只追踪指定类型的物体
Trace Channel：射线检测，对指定遮挡的物体进行最终，一般默认全部忽略，然后对希望被检测的物体设置阻挡
ignore 忽略，湖绿不会被检测到
Overlap 可以检测到，但会穿过物体，物体后面的物体也会被检测到
Block 阻挡，阻挡会被检测到

## 摄像头震荡
右键内容浏览器-->Blueprints蓝图类-->搜索CameraShake
Oscillation Duration：震荡持续时间
Oscillation Blend in Time：震荡混入时间
Oscillation Blend Out Time：震荡混出时间

Rot Oscillation：旋转震荡
Loc Oscillation：位置震荡
FOV Oscillation：镜头远近震荡

GetPlayerCameraManager-->PlayCameraShake
PlayCameraShake:
Shake Class:选择创建的摄像机晃动蓝图类

## 准星
右键内容浏览器-->UserInterface用户接口-->Widget Blueprint部件蓝图
Broder拖入中间，将Anchors锚点设置为中间Position X和Position Y设置为0，Size X设置为2，Size Y设置为15
然后将Alignment对准调整为X 0.5和Y 0.5，并Ctrl + W复制5个，
将其中一个Size X和Size Y设置为2，其中两个调整上下位置
另外两个在details面板Render Transform中Angel设置为90，
稍作调整，去掉中心。

## 下看视角限制
**功能需求**：限制我们鼠标向下的移动范围，以避免手臂与身体重合。
鼠标输入时，向上移动为负度数，向下移动为正度数
摄像机获得世界坐标后，向上移动为0 ~ 90，向下为0 ~ -90，我们想将移动范围限制到-70 ~ 90
采用Branch分流，当CameraY轴角度大于-70时，可以随意移动。
但当小于-70时，进一步判断鼠标向上移动可以，不能向下移动。

## 人物跳跃动画
动画蓝图中，设置变量IsJump，
时间图表中获取Player状态，使用IsFalling，在空中IsFalling为1，赋给IsJump
采用IsJump作为BlendPosesByPool的参数。

## 设置AI

右键内容浏览器-->Character类
mesh选小白人做模型，Collision只选择子弹阻挡
Player蓝图射线检测处，将LineTraceByChannel和OutHit引脚打开
使用ApplyDamage，将outHitActor接入ApplyDamage的damaged Actor被攻击者

在AI蓝图的事件图表中，创建EventAnyDamage和AI_Life_Value
EventAnyDamage中设置AI_Life_Value
AI_Life_Value 减去 EventAnyDamage中damage作为接入AI_Life_Value设置引脚

EventTick中采用Branch判断，如果AI_Life_Value小于等于0，对Mesh使用SetSimulatePhysics函数并delay 1秒后DestroyActor
如果没有进行物理模拟，说明没有添加物理资源
如果掉下地面，说明没有启用碰撞

## AI自动追踪攻击
建立AI动画蓝图，总共三个动作，站立、行走、攻击，可以按照速度通过BlendPosesByPool函数进行设置。
Edit-->Project Setting-->Collision-->创建两个物体Player和Enemy，默认为阻挡
EventTick可以并行，S + 鼠标左键可以调出Sequence序列，
新建变量IsTrace默认打开，采用Branch分流，
如果IsTrace打开，执行SimpleMoveToActor，GetAlController作为Controller，Player作为Goal
如果IsTrace关闭，执行StopMovementInmediately，

给AI设置BoxCollision，AI的胶囊体和Mesh都在Collision中设置Collision Presets为Custom，Object Type为Enemy，只有Visibility和Enemy忽略，其余Block
但是，Box要设置所有忽略，只有Player为Overlap重叠。
OnComponentBeginOverlap(Box)-->IsTrace关闭-->delay 1s
Branch分流，IsTrace为条件，False执行ApplyDemege，Player为DemegedActor被攻击者，接到delay之间循环
OnComponentEndOverlap(Box)-->IsTrace打开
