---
layout:     post
title:      UE4 C++
subtitle:   基础内容
date:       2020-4-19
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - UE4 C++系列
---

## UE4C++实际用途
1）游戏算法：当某个游戏算法十分复杂的时候，比如弹道计算，采用蓝图开发效率比较低<br>
2）C++网络通信：当多人联机时需要C++写一些通信方面的内容。<br>
3）游戏引擎深度定制：当游戏项目很大时，游戏开发引擎不能满足所有的功能，需要采用C++深度开发

## 常见的宏-UPROPERTY
UPROPERTY 用途广泛。它允许变量被复制、被序列化，并可从蓝图中进行访问。垃圾回收器还使用它们来追踪对 UObject 的引用数。<br>
### EditAntwhere / VisibleAnywhere
EditAntwhere 表示此属性可以通过属性窗口，原型和实例进行编辑（原型指的是类模板，实例指的是具体的对象实例）<br>
VisibleAnywhere 指示此属性在所有属性窗口中都可见，但无法编辑。这个标签与“Edit”标签不兼容
```
UPROPERTY(VisibleAnywhere, Category = "Snowing|Visible")
    FString VisibleAnywhereParam;

UPROPERTY(EditAnywhere, Category = "Snowing|Edit")
    float EditAnywhereParam;
```
![](https://img-blog.csdn.net/20171109100457996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjc5MzEwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### BlueprintReadWrite
设置属性为蓝图读写。会在蓝图脚本中为被修饰的变量提供 Get 和 Set 方法
```
UPROPERTY(BlueprintReadWrite, Category = "Snowing|Blueprint")
    float BlueprintReadWriteParam;
```
![](https://img-blog.csdn.net/20171108170010210?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjc5MzEwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### BluprintReadOnly
设置属性为蓝图只读。会在蓝图脚本中为被修饰的变量提供 Get 方法，没有 Set 方法
```
UPROPERTY(BlueprintReadOnly, Category = "Snowing|Blueprint")
    float BlueprintReadOnlyParam;
```
![](https://img-blog.csdn.net/20171108165721356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjc5MzEwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### Category 
指定在Blueprint编辑工具中显示的属性的类别。使用|定义嵌套层级
```
UPROPERTY(VisibleAnywhere, Category = "Snowing|Visible")
    FString VisibleAnywhereParam;

UPROPERTY(VisibleInstanceOnly, Category = "Snowing|Visible")
    FString VisibleInstanceOnlyParam;

UPROPERTY(EditAnywhere, Category = "Snowing|Edit")
    float EditAnywhereParam;

UPROPERTY(EditInstanceOnly, Category = "Snowing|Edit")
    float EditInstanceOnlyParam;
```
![](https://img-blog.csdn.net/20171108205714775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjc5MzEwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## UFUNCTION
基本功能：定义能够被UE识别的函数
### BlueprintCallable
该函数可以在蓝图或关卡蓝图图表中执行
```
public: 
    UFUNCTION(BlueprintCallable, Category = "Snowing,BlueprintFunc")
        void BlueprintCallableFunction();
```
![](https://img-blog.csdn.net/20171110103239399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjc5MzEwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 添加摄像机功能
**功能需求**：在我们添加物体之后，摄像机追踪物体的运动，相当于蓝图中AddComponent添加组件。
首先我们需要添加三个组件，分别是静态网格体，
```
//SphereBase.h中创建组件

public:

UPROPERTY(EditAnywhere, BlueprintReadWrite)
		UStaticMeshComponent * SphereMesh;
        
//SphereBase.cpp中  

ASphereBase::ASphereBase()
{
 	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
    //添加组件实例，就等于在蓝图中AddComponent功能
	SphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("SphereBase"));
	
}
![](https://github.com/AIaimuti/aiaimuti.github.io/blob/master/img/UE4/Component.png)
```
### 按键轴映射
1)Projrct Setting-->Engine-->input中设置好轴映射<br>
2).h文件中添加函数声明<br>
轴映射一般是持续的数值，所以加一个float参数。
```
UFUNCTION(BlueprintCallable)
    void Moveforward(float val);

UFUNCTION(BlueprintCallable)
    void MoveRight(float val);
```
3).cpp文件中添加函数和轴映射
```
void ASphereBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
	//对之前在Projrct Setting中设置好的轴映射进行调用
	PlayerInputComponent->BindAxis("Moveforward",this,&ASphereBase::Moveforward);
	PlayerInputComponent->BindAxis("MoveRight", this, &ASphereBase::MoveRight);

}

void ASphereBase::Moveforward(float val)
{	//前后方向测试
	GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Blue, FString::SanitizeFloat(val));
}

void ASphereBase::MoveRight(float val)
{	//左右方向测试
	GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, FString::SanitizeFloat(val));
}
```
![](https://github.com/AIaimuti/aiaimuti.github.io/blob/master/img/UE4/Axis.png)
## 加速功能
**功能需求**：按下空格或者shift速度变快。
1)1)Projrct Setting-->Engine-->input中设置好按键映射<br>
2)

### 杂项总结
1)类型转换<br>
FString::FromInt：UE4中将int类型转化为String类型<br>
FString::SanitizeFloat： UE4中将float类型转化为String类型<br>
2)Object和Actor区别，Actor能挂载组件，Object不能挂载组件<br>
3)Component组件是类的成员，使用前面加U，例如UStaticMeshComponent，静态网格体组件前面加U;UInputComponent，输入组件前面加U<br>
4）Ctrl + Shift + B 不运行，只编译<br>
5)为了避免两个头文件互相引用，一般不在.h文件中导入太多的别的头文件，<br>
如果你只是想在另外一个类中定义一个类的成员变量，只要在头文件中加入 class 类名;<br>
然后要在.cpp文件中包含这个头文件就可以了<br>
6)Bug：** 添加新的头文件时，要将头文件放在.generated.h之前，不然可能出错**<br>
7)有时候改写C++类了以后，其蓝图类需要重新继承，才会有变化。<br>
8)采用UPROPETRTY()声明了某个类的成员，一般在命名时在后面加上组件属性，如添加组件，可以起名SphereMeshComp，其中Comp说明其是组件。<br>
9)OnComponentBeginOverlap是一个宏函数，有六个参数，平常很难记住这么多参数，不知道的函数可以去F12看源码，多看多积累
10)有时候用C++写好类，继承到蓝图时，有时改代码不生效，删除蓝图重新继承一下可能会有效果。

