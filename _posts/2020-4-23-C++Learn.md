---
layout:     post
title:      UE4 C++入门
subtitle:   基础内容
date:       2020-4-19
author:     AIaimuti
header-img: img/post-bg-open-source-blog.jpg
catalog: true
tags:
    - UE4 C++入门
---

## reflection反射机制
就是UE4的各种宏，将程序内容反射到UE4蓝图中
.generated.h里面有反射机制的相关实现，
Uneal Header Tool(UHT)会建立一些反射以及代码与蓝图之间的联系。

## Garage Collection垃圾回收机制
UE4的机制是被引用的指针不能释放，没有引用的指针可以释放

## Object和actor的区别
Object不能挂载组件，而actor可以
创建Pulic和Private文件夹时，头文件出现红线，可以采用如下形式：
#include "..\Public\MyObject.h"
包含相对路径，就可以识别

## 在蓝图中使用UObject
UCLASS(Blueprintable) C++类可继承为蓝图

## Actor
construct object from class 为某个类创建一个实例
window-->Developer Tools-->Output Log 开启输出日志
内容管理器里向下的小箭头Import可以导入资源

## 场景空间
Shift + End 将底部中心对齐到地面
transform里的单位都是厘米
前是红色X轴 上是蓝色Z轴 右是绿色Y轴
FVector设置一个浮点数，就三个轴都是这个
UPROPERTY()
edit：
EditAnywhere 在任何地方都可以看到和编辑
EditInstanceOnly 只在实例窗口可以看到和编辑 蓝图里看不到不能编辑
EditDefaultsOnly 只能在蓝图窗口里编辑 实例窗口看不到不能编辑
Visible:
VisibleAnywhere 任何地方可见
VisibleInstanceOnly 实例中
VisibleDefaultsOnly 蓝图中可见

## 条件编译指令 #if #else #endif
#if #else #endif 可以用来写分支，没选中的代码会变灰

## 碰撞相关
### UE_LOG
测试输出
`UE_LOG(LogTemp, Warning, TEXT("Warning!"));`

### AddActorLocalOffset
AddActorLocalOffset 向Actor的局部坐标添加位置增量
```
void AddActorLocalOffset
（
    FVector DeltaLocation，
    bool bSweep，
    FHitResult * OutSweepHitResult，
    ETeleportType Teleport
）
```
DeltaLocation: FVector变量，Actor局部坐标的增加量
bSweep: 检测Actor运动过程是否发生碰撞重叠
OutSweepHitResult: 碰撞结果，有一系列参数，如碰撞位置
bTeleport: 是否传送物理状态

类似的，还有AddActorWorldOffset 向Actor的世界坐标添加位置增量

### AddActorLocalRotation
AddActorLocalRotation 向Actor的局部坐标添加旋转量量
```
void AddActorLocalRotation
(
    const FQuat & DeltaRotation,
    bool bSweep,
    FHitResult * OutSweepHitResult,
    ETeleportType Teleport
)
```
DeltaLocation: FVector变量，Actor局部坐标的增加量
bSweep: 检测Actor运动过程是否发生碰撞或重叠
OutSweepHitResult: 碰撞结果，有一系列参数，如碰撞位置
bTeleport: 是否传送物理状态

类似的，还有AddActorWorldRotation 向Actor的世界坐标添加旋转量

### 信息输出改进
输出碰撞信息:
```
//直接使用浮点数输出，小数点位数较多
UE_LOG(LogTemp, Warning,
    TEXT("%%f Hit@: x=%f,y=%f,z=%f"),
    HitResult.Location.X, HitResult.Location.Y, HitResult.Location.Z);
//采用字符串输出，小数点后两位
UE_LOG(LogTemp, Warning,
    TEXT("%%s Hit@: x=%s,y=%s,z=%s"),
    *FString::SanitizeFloat(HitResult.Location.X),
    *FString::SanitizeFloat(HitResult.Location.Y),
    *FString::SanitizeFloat(HitResult.Location.Z);
```
1左边的符号 可以调出cmd进行调控

## 世界坐标和局部坐标
### FVector与FRotator
FVector 位置三维坐标
FRotator 旋转三维坐标
### FRotator旋转属性对应
沿着那个轴，哪个轴就不动，
世界坐标系中红色的是Roll，沿着X轴即前后方向旋转，一般来说FPS游戏不用动这个角度
绿色的是pitch，沿着Y轴即左右方向旋转，FPS游戏中可以向上向下瞄准
蓝色的是yaw值，沿着Z轴即上下方向旋转，FPS游戏中可以左右扫射
`FORCEINLINE FRotator::FRotator( float InPitch, float InYaw, float InRoll )`
FRotator中第一个是沿着Y轴旋转的角度，第二参数是沿着z轴旋转的角度(FPS很少用)，第三个参数是沿着x轴旋转的角度。

## 力和扭矩
Force和Torque
Force是按一个方向移动的力
Torque是按一个方向旋转的力

如果使用了->来访问类的成员，就需要添加相应的头文件
Physics-->Constrains(约束)-->lock Position/lock Rotation 锁定指定位置X、Y、Z坐标/ 锁定旋转的X、Y、Z值

Sequence 顺序 其实是协程
## 数学函数
游戏弹道算法-->数学函数插件?
正弦函数
```
//正弦函数配置
float InitialX = FMath::FRand() * 500;
float InitialY = FMath::FRandRange(100,500);
float InitialZ = 0;
SetActorLocation(FVector(InitialX, InitialY, InitialZ));
```

## 初识Pawn(棋子)类
USceneComponent 场景根组件，一般物体都有（很有必要添加，不然后续附着别的组件可能有问题）
GamemodeBase-->继承蓝图-->details-->Classes-->Default Pawn Class可以选取我们想默认生成的Pawn
然后再世界场景中选取我们自定义的游戏模式

## 控制移动
让0号玩家拥有控制权
`AutoPossessPlayer = EAutoReceiveInput::Player0;`
先Project Setting添加轴映射-->添加Components/InputComponent.h头文件-->SetupPlayerInputComponent中绑定函数
### MoveForward和MoveRight
```
void ACreature::MoveForward(float Value)
{
	CurrentVelocity.X = FMath::Clamp(Value, -1.f, 1.f)* MaxSpeed;
}

void ACreature::MoveRight(float Value)
{
	CurrentVelocity.Y = FMath::Clamp(Value, -1.f, 1.f)* MaxSpeed;
}
```
将速度限制到-1到1 * MaxSpeed
`CurrentVelocity.X = FMath::Clamp(Value, -1.f, 1.f)* MaxSpeed;`
FMath::Clamp
介于最大值最小值之间
### 移动实现
```
void ACreature::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	//新位置等于当前位置+速度*每帧时间
	FVector NewLocation = GetActorLocation() + CurrentVelocity * DeltaTime;
	SetActorLocation(NewLocation);

}
```
在Tick中实现

## 完善运动
### 球形组件配置
```
//实例化球形组件
SphereComp = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComp"));
//设置半径
SphereComp->SetSphereRadius(80);
//设置初始碰撞类型
SphereComp->SetCollisionProfileName(TEXT("Block All"));
//设置球形组件是否隐藏，不设置的话默认隐藏
SphereComp->SetHiddenInGame(false);
//设置根组件
SetRootComponent(SphereComp);
```
#### ConstructorHelpers直接指定并添加静态网格体资源
直接指定网格资源采用如下方式，需要添加Uobject/ConstructorHelpers.h头文件。
TEXT内部引用的路径：打开actor蓝图-->Static Mesh点放大镜打开内容浏览器-->在内容浏览器中右键点击所选物体-->点击Copy Reference
```
//直接指定静态网格体资源
static ConstructorHelpers::FObjectFinder<UStaticMesh>MeshComponentAsset
        (TEXT("StaticMesh'/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere'"));
//如果获取成功
if (MeshComponentAsset.Succeeded())
	{
        //
		MeshComponent->SetStaticMesh(MeshComponentAsset.Object);
		MeshComponent->SetRelativeLocation(FVector(0.f, 0, -50));
	}
```
有时编译好了会没有变化，这时点类设置，换一下蓝图的父类，然后再还回去

### 摄像机弹簧臂配置
设置了弹簧臂长度、位置以及作为谁的附件，并开启摄像机延迟<br>
#### SetupAttachment函数
void SetupAttachment
(
    USceneComponent * InParent,
    FName InSocketName
)
InParent：指定依附对象
InSocketName：指定插槽名称

弹簧臂一段连接物体原点，另一端自带插槽。这里将摄像机绑定弹簧臂的插槽，不然摄像机会绑定到弹簧臂的原点
`Camera->SetupAttachment(SpringArmComp, USpringArmComponent::SocketName);`
#### 具体实现
```
#if 1
	//实例化弹簧臂组件
	SpringArmComp = CreateDefaultSubobject<USpringArmComponent>(TEXT("SpringArmComp"));
	//弹簧臂组件组件附着在根组件
	SpringArmComp->SetupAttachment(RootComponent);
	//弹簧臂组件长度设为400
	SpringArmComp->TargetArmLength = 400;
	//设置弹簧臂组件位置
	SpringArmComp->SetRelativeRotation(FRotator(-45.f, 0, 0));
	//开启摄像机延迟
	SpringArmComp->bEnableCameraLag = true;
	//设置摄像机延迟速度
	SpringArmComp->CameraLagSpeed = 4;
#endif
	Camera = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));
#if 1
	//摄像机绑定弹簧臂，位置是插槽的位置，如果没有指定，摄像机会绑定在弹簧臂自身原点的位置
	//弹簧臂的另一端自带插槽
	Camera->SetupAttachment(SpringArmComp, USpringArmComponent::SocketName);
```
### 自定义动作组件
**功能需求:** 球体碰撞到墙壁时，沿边移动。<br>
1)创建一个继承自UPawnMovementComponent的C++类<br>
`class UGDC_API UMyPawnMovementComponent : public UPawnMovementComponent`<br>

2)覆写 TickComponent以形成我们的自定义运动组件<br>
从父类依次寻找找到函数定义<br>
UPawnMovementComponent-->UNavMovementComponent-->UMovementComponent<br>
UMovementComponent中有函数TickComponent<br>
`virtual void TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction) override;`

3)实现过程<br>
Creature中声明自定义运动组件-->条件判断-->获取运动向量-->sweep扫描并实现溜边运动<br>
**Creature中声明自定义运动组件：**<br>
Creature.h文件中声明<br>
```
UPROPERTY(VisibleAnywhere)
    class UMyPawnMovementComponent * MovementComp;

virtual UPawnMovementComponent * GetMovementComponent() const override;
```
首先定义UMyPawnMovementComponent类的MovementComp变量；<br>
覆写UPawnMovementComponent的GetMovementComponent()函数，返回我们指定的运动组件来控制Pawn的运动<br>
Creature.cpp文件中<br>
实例化继承后的UMyPawnMovementComponent类MovementComp，并指定根组件作为我们移动和更新的标准<br>
GetMovementComponent()中使用我们自定义的移动组件
```
MovementComp = CreateDefaultSubobject<UMyPawnMovementComponent>(TEXT("MovementComp"));
//设置移动和更新的标准，以根组件我们移动和更新的标准
MovementComp->UpdatedComponent = RootComponent;
    
UPawnMovementComponent * ACreature::GetMovementComponent() const
{   //使用我们自定义的移动组件
	return MovementComp;
}
```

**条件判断：**
PawnOwner：运动是必须要有Owner的，没有会返回空向量<br>
UpdatedComponent：UpdatedComponent指定以某个组件的运动和更新视为整体的运动和更新，在Creature.cpp 87行设置了以根组件为准<br>
ShouldSkipUpdate(DeltaTime):允许自动跳过更新，有时候没有对Pawn进行操作，就不需要对其更新
```
//运动是必须要有Owner的，没有会返回空向量
//UpdatedComponent指定以某个组件的运动和更新视为整体的运动和更新，在Creature.cpp 87行设置了以根组件为准
//允许自动跳过更新，有时候没有对Pawn进行操作，就不需要对其更新

if (!PawnOwner || !UpdatedComponent || ShouldSkipUpdate(DeltaTime))
{
    return;
}
```
**获取运动向量：**
ConsumeInputVector():消费者，消费运动向量<br>
GetClampedToMaxSize(1): 约束最大长度为1
```
//ConsumeInputVector消费运动向量
//GetClampedToMaxSize约束最大长度为1
//功能是获取运动向量的方向，然后按这个方向以150的速度运动
FVector DeltaMovement
    = ConsumeInputVector().GetClampedToMaxSize(1) * DeltaTime * 150;
```
**sweep扫描并实现溜边运动：**
IsNearlyZero:在指定小数点阈值内输出true,用于容错<br>
SafeMoveUpdatedComponent：进行运动的试算，并开启sweep扫描，有阻挡会输出撞击信息<br>
HitResult.IsValidBlockingHit：检测是有有效的撞击<br>
SlideAlongSurface：延边滑动
```
virtual FVector ComputeSlideVector
(
    const FVector & Delta,
    const float Time,
    const FVector & Normal,
    const FHitResult & Hit
) const
```
Delta:尝试移动的方向<br>
Time：通常为1-碰撞时间，即1-Hit.Time<br>
Normal：法向，正常的相对运动方向<br>
Hit：碰撞结果

```
//如果有运动向量输入，IsNearlyZero在指定小数点阈值内输出true，非0就是有运动向量输入
if (!DeltaMovement.IsNearlyZero())
{
    FHitResult HitResult;
    //采用SafeMoveUpdatedComponent进行运动的试算，其中sweep参数设为true
    SafeMoveUpdatedComponent(DeltaMovement,
        UpdatedComponent->GetComponentRotation(), true, HitResult);
    //如果有有效的阻挡碰撞，就溜边运动，HitResult.Normal法向
    if (HitResult.IsValidBlockingHit())
    {
        SlideAlongSurface(DeltaMovement,
            1 - HitResult.Time, HitResult.Normal, HitResult);
    }
}
```
**运动函数改变**
AddInputVector:将给定向量添加到世界空间的累积输入中。输入向量的大小通常在0到1之间。它们在帧中累积，然后在运动更新期间用作加速度。
```
virtual void AddInputVector
(
    FVector WorldVector,
    bool bForce
)
```
WorldVector:在世界空间中应用输入的方向
bForce:如果为true，则始终添加输入

GetActorForwardVector:获取Actor在世界空间的正向(X)方向，取值-1，0，1
GetActorRightVector：获取Actor在世界空间的右向(Y)方向，取值-1，0，1
```
void ACreature::MoveForward(float Value)
{
	//CurrentVelocity.X = FMath::Clamp(Value, -1.f, 1.f)* MaxSpeed;
	if (MovementComp)
	{
		MovementComp->AddInputVector(GetActorForwardVector() * Value);
	}

}

void ACreature::MoveRight(float Value)
{
	//CurrentVelocity.Y = FMath::Clamp(Value, -1.f, 1.f)* MaxSpeed;
	if (MovementComp)
	{
		MovementComp->AddInputVector(GetActorRightVector() * Value);
	}
}
```
这种写法考虑了脸的朝向，角色转身后也是脸的正向
